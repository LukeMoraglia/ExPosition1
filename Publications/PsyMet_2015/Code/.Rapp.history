rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')#
##Co-dominant#
CD.SNPS <- SNP.model.maker(SNPS,'c')#
res<-tepPLSCA(CD.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Dominant#
D.SNPS <- SNP.model.maker(SNPS,'d')#
res<-tepPLSCA(D.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
library(TExPosition)#
SNP.model.maker <- function(SNPS,model='C',quant.vals=c(0.5,0.5)){#
	if(sum(quant.vals)!=1){#
		stop("sum of quant.vals must equal 1.")#
	}#
	SNPS.out <- SNPS#
	class(SNPS.out) <- "character"#
	if(tolower(model)=='c'){#
		SNPS.out <- replace(SNPS.out, SNPS.out=='0','AA')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='1','Aa')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='2','aa')#
		checks <- column.checker(SNPS.out)#
		SNPS.keep <- makeNominalData(checks$KEEP)			#
	}#
#
	if(tolower(model)=='d'){#
		SNPS.out <- replace(SNPS.out, SNPS.out=='0','ND')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='1','D')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='2','D')#
		checks <- column.checker(SNPS.out)#
		SNPS.keep <- makeNominalData(checks$KEEP)					#
	}#
#
	if(tolower(model)=='r'){#
		SNPS.out <- replace(SNPS.out, SNPS.out=='0','NR')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='1','NR')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='2','R')#
		checks <- column.checker(SNPS.out)#
		SNPS.keep <- makeNominalData(checks$KEEP)					#
	}#
	if(tolower(model)=='o'){#
		SNPS.out <- replace(SNPS.out, SNPS.out=='0','NOD')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='1','OD')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='2','NOD')#
		checks <- column.checker(SNPS.out)#
		SNPS.keep <- makeNominalData(checks$KEEP)#
	}#
	if(tolower(model)=='q'){#
		SNPS.out <- replace(SNPS.out, SNPS.out=='0','AA')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='1','Aa')#
		SNPS.out <- replace(SNPS.out, SNPS.out=='2','aa')#
		checks <- column.checker(SNPS.out)#
		SNPS.keep <- two.column.maker(checks$KEEP,quant.vals)#
	}#
	return(list(SNPS=SNPS.keep,DROPPED=checks$DROPPED))#
}#
two.column.maker <- function(SNPS.in,quant.vals=c(0.5,0.5)){#
	SNPS.out <- matrix(0,nrow(SNPS.in),ncol(SNPS.in)*2)#
	colnames(SNPS.out) <- unlist(lapply(colnames(SNPS.in),function(x){paste(x,c("A","a"),sep=".")}))#
	col.map <- seq(1,ncol(SNPS.out),2)#
	for(i in 1:ncol(SNPS.in)){#
		SNPS.out[which(SNPS.in[,i]=='AA'),col.map[i]] <- 1#
		SNPS.out[which(SNPS.in[,i]=='aa'),col.map[i]+1] <- 1	#
		SNPS.out[which(SNPS.in[,i]=='Aa'),c(col.map[i],col.map[i]+1)] <- quant.vals#
#
	}#
	return(SNPS.out)#
}#
column.checker <- function(DAT){#
	uniq.check <- apply(DAT,2,function(x){length(unique(x))})#
	drop.cols <- which(uniq.check == 1)#
	keep.cols <- which(uniq.check > 1)	#
	KEEP.DATA <- as.matrix(DAT[,keep.cols])#
	DROP.DATA <- as.matrix(DAT[,drop.cols])#
	rownames(KEEP.DATA) <- rownames(DAT)#
	rownames(DROP.DATA) <- rownames(DAT)	#
	if(length(drop.cols) >= 1){#
		warning("Some columns dropped. See $DROPPED")#
	}#
	return(list(KEEP=KEEP.DATA,DROPPED=DROP.DATA))#
}
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')
#Dominant#
D.SNPS <- SNP.model.maker(SNPS,'d')#
res<-tepPLSCA(D.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Recessive#
R.SNPS <- SNP.model.maker(SNPS,'r')#
res<-tepPLSCA(R.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')#
CD.SNPS <- SNP.model.maker(SNPS[,1:4],'c')#
D.SNPS <- SNP.model.maker(SNPS[,5:6],'d')#
A.SNPS <- SNP.model.maker(SNPS[7:9],'q',c(0.5,0.5))
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')#
CD.SNPS <- SNP.model.maker(SNPS[,1:4],'c')#
D.SNPS <- SNP.model.maker(SNPS[,5:6],'d')#
A.SNPS <- SNP.model.maker(SNPS[,7:9],'q',c(0.5,0.5))
SNP.DAT <- cbind(CD.SNPS$SNPS,D.SNPS$SNPS,A.SNPS$SNPS)
SNP.DAT
dim(SNP.DAT)
rowSums(SNP.DAT)
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')#
CD.SNPS <- SNP.model.maker(SNPS[,1:4],'c')#
D.SNPS <- SNP.model.maker(SNPS[,5:6],'d')#
A.SNPS <- SNP.model.maker(SNPS[,7:9],'q',c(0.5,0.5))#
#
SNP.DAT <- cbind(CD.SNPS$SNPS,D.SNPS$SNPS,A.SNPS$SNPS)#
##quick check:#
rowSums(SNP.DAT)#
#
##Mixed#
res<-tepPLSCA(SNP.DAT,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda')#
load('../Data/TRAITS.rda')#
load('../Data/DES.rda')#
##Co-dominant#
CD.SNPS <- SNP.model.maker(SNPS,'c')#
res<-tepPLSCA(CD.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Dominant#
D.SNPS <- SNP.model.maker(SNPS,'d')#
res<-tepPLSCA(D.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Recessive#
R.SNPS <- SNP.model.maker(SNPS,'r')#
res<-tepPLSCA(R.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Overdominant#
O.SNPS <- SNP.model.maker(SNPS,'o')#
res<-tepPLSCA(O.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Additive#
A.SNPS <- SNP.model.maker(SNPS,'q',c(0.5,0.5))#
res<-tepPLSCA(A.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Multiplicative#
M.SNPS <- SNP.model.maker(SNPS,'q',c(0.25,0.75))#
res<-tepPLSCA(M.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Multiplicative 2#
M2.SNPS <- SNP.model.maker(SNPS,'q',c(0.1,0.9))#
res<-tepPLSCA(M2.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
#Multiplicative 3#
M3.SNPS <- SNP.model.maker(SNPS,'q',c(0.9,0.1))#
res<-tepPLSCA(M3.SNPS$SNPS,TRAITS,FALSE,TRUE,DESIGN=DES,FALSE,graphs=FALSE)#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
####This script shows how to use a variety of genetic inheritance models with PLSCA.#
###These match the ideas presented in the paper (co-dominant) as well as Appendix B.#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
##The trait data will be used exactly as is for all analyses in this script.#
cat.TRAITS <- makeNominalData(TRAITS)#
trait.names <- unlist(lapply(strsplit(colnames(cat.TRAITS),"\\."),function(x){x[3]}))#
trait.colors <- as.matrix(trait.names)#
trait.colors <- replace(trait.colors,trait.colors=="HI",'firebrick3')#
trait.colors <- replace(trait.colors,trait.colors=="MID",'goldenrod')#
trait.colors <- replace(trait.colors,trait.colors=="LOW",'olivedrab4')#
#
##participant colors#
part.colors <- createColorVectorsByDesign(DES)#
##Full categorical i.e., co-dominant#
CD.SNPS <- SNP.model.maker(SNPS,'c')#
cd.zygosity <- unlist(lapply(strsplit(colnames(CD.SNPS$SNPS),"\\."),function(x){x[3]}))#
cd.colors <- as.matrix(cd.zygosity)#
cd.colors <- replace(cd.colors, cd.colors =="AA",'steelblue4')#
cd.colors <- replace(cd.colors, cd.colors =="Aa",'mediumorchid4')#
cd.colors <- replace(cd.colors, cd.colors =="aa",'orangered')#
res<-tepPLSCA(CD.SNPS$SNPS, cat.TRAITS,FALSE,FALSE,DESIGN=DES,FALSE,graphs=FALSE)#
res$Plotting.Data$fi.col <- cd.colors#
res$Plotting.Data$fj.col <- trait.colors#
res$Plotting.Data$fii.col <- part.colors$oc#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)#
#Dominant#
D.SNPS <- SNP.model.maker(SNPS,'d')#
d.zygosity <- unlist(lapply(strsplit(colnames(D.SNPS$SNPS),"\\."),function(x){x[3]}))#
d.colors <- as.matrix(d.zygosity)#
d.colors <- replace(d.colors, d.colors =="ND",'steelblue4')#
d.colors <- replace(d.colors, d.colors =="D",'orangered')#
res<-tepPLSCA(D.SNPS$SNPS,cat.TRAITS,FALSE,FALSE,DESIGN=DES,FALSE,graphs=FALSE)#
res$Plotting.Data$fi.col <- d.colors#
res$Plotting.Data$fj.col <- trait.colors#
res$Plotting.Data$fii.col <- part.colors$oc#
tepGraphs(res,lvAgainst=FALSE,contributionPlots=FALSE)
load("/Volumes/JOHNNYFIVE/Professional/Software/ExPosition-Family/Publications/PsyMet_2015/Data/CONTINUOUS.rda")
load("/Volumes/JOHNNYFIVE/Professional/Software/ExPosition-Family/Publications/PsyMet_2015/Data/DES.rda")
ls()
DES
CONT.DATA
CONTINUOUS <- CONT.DATA
rownames(CONTINUOUS) <- rownames(DES)
save(CONTINUOUS,file='../Data/CONTINUOUS.rda')
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/TRAITS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS1 <- tepPLSCA(
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F)
SNPS
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F)
traceback()
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F)
escofier.transform(CONTINUOUS)
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F)
colnames(CONTINUOUS)
dim(CONTINUOUS)
colnames(CONTINUOUS) <- paste0("VAR.",1:30)
save(CONTINUOUS,file='../Data/CONTINUOUS.rda')
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F)
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)
mimoPLS1 <- tepPLSCA(TRAITS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)
expo.scale(CONTINUOUS)+1
## with the Escofier recoding transform:#
mimoPLS1 <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)#
#
	## with the shortcut to Escofier recoding (see Beaton et al., 2016: http://utd.edu/~herve/abdi-bkadfa2016-mimopls.pdf):#
mimoPLS2 <- tepPLSCA(SNPS,expo.scale(CONTINUOUS)+1,T,F,DESIGN=DES,make_design_nominal=F)
mimoPLS1$TExPosition.Data$fi / mimoPLS2$TExPosition.Data$fi
mimoPLS2 <- tepPLSCA(SNPS,expo.scale(CONTINUOUS)+1,T,F,DESIGN=DES,make_design_nominal=F)
expo.scale(CONTINUOUS)+1
sum(expo.scale(CONTINUOUS)+1)
dim(CONTINUOUS)
60*30
mimoPLS2 <- tepPLSCA(SNPS,1+expo.scale(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)
mimoPLS1$TExPosition.Data$fi / mimoPLS2$TExPosition.Data$fi
mimoPLS1$TExPosition.Data$fj / mimoPLS2$TExPosition.Data$fj
mimoPLS1$TExPosition.Data$fj[1:30,] / mimoPLS2$TExPosition.Data$fj[1:30,]
perm.samples <- sample(nrow(SNPS),nrow(SNPS),F)
mimoPLS.perm <- tepPLSCA(SNPS[perm.samples,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)#
	mimoPLS.perm$TExPosition.Data$eigs
perm.samples <- sample(nrow(SNPS),nrow(SNPS),F)#
	mimoPLS.perm <- tepPLSCA(SNPS[perm.samples,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graph=F)#
	mimoPLS.perm$TExPosition.Data$eigs
### Permutation#
perm.iters <- 100#
perm.eigs <- matrix(NA,perm.iters,length(mimoPLS$TExPosition.Data$eigs))#
#
for(i in 1:perm.iters){#
	perm.samples <- sample(nrow(SNPS),nrow(SNPS),F)#
	mimoPLS.perm <- tepPLSCA(SNPS[perm.samples,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graph=F)#
	perm.eigs[i,] <- mimoPLS.perm$TExPosition.Data$eigs#
}
## with the Escofier recoding transform:#
mimoPLS <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F)#
## Examples of inference tests below. Only permutation and bootstrap provided.#
#
	### Permutation#
perm.iters <- 100#
perm.eigs <- matrix(NA,perm.iters,length(mimoPLS$TExPosition.Data$eigs))#
#
for(i in 1:perm.iters){#
	perm.samples <- sample(nrow(SNPS),nrow(SNPS),F)#
	mimoPLS.perm <- tepPLSCA(SNPS[perm.samples,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graph=F)#
	perm.eigs[i,] <- mimoPLS.perm$TExPosition.Data$eigs#
}
perm.eigs
mimoPLS$TExPosition.Data$eigs
matrix(mimoPLS$TExPosition.Data$eigs,perm.iters,byrow=T)
matrix(mimoPLS$TExPosition.Data$eigs,nrow=perm.iters,byrow=T)
matrix(mimoPLS$TExPosition.Data$eigs,perm.iters,length(mimoPLS$TExPosition.Data$eigs),byrow=T)
original.eigs.matrix > perm.eigs
original.eigs.matrix <- matrix(mimoPLS$TExPosition.Data$eigs,perm.iters,length(mimoPLS$TExPosition.Data$eigs),byrow=T)#
#
	### test each component:#
original.eigs.matrix > perm.eigs
colSums(original.eigs.matrix > perm.eigs)
colSums(original.eigs.matrix > perm.eigs) / perm.iters
colSums(original.eigs.matrix < perm.eigs) / perm.iters
colSums(original.eigs.matrix > perm.eigs) / perm.iters
1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters)
pmin(1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters),1/100)
pmax(1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters),1/100)
sum(mimoPLS$TExPosition.Data$eigs)
sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs)
(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs)) / perm.iters
(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))
sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))
sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))  / perm.iters
1-(sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))  / perm.iters)
### test each component:#
component.p.values <- pmax(1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters), 1/perm.iters)#
	### omnibus test#
#
omnibus.p.value <- max(1-(sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))  / perm.iters), 1/perm.iters)
omnibus.p.value
component.p.values
nom.SNPS <- makeNominalData(SNPS)
boot.samples <- sample(nrow(SNPS),nrow(SNPS),T)#
	boot.nom.SNPS <- nom.SNPS[boot.samples,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.samples,])
boot.ESCOFIER.CONTINUOUS
boot.nom.SNPS
boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS
sum(boot.R)
library(TInPosition)
boot.samples
InPosition::boot.samples
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graphs=F)#
## Examples of inference tests below. Only permutation and bootstrap provided.#
#
	### Permutation: 100 iterations only. Increase as required.#
perm.iters <- 100#
perm.eigs <- matrix(NA,perm.iters,length(mimoPLS$TExPosition.Data$eigs))#
for(i in 1:perm.iters){#
	perm.sample <- sample(nrow(SNPS),nrow(SNPS),F)#
	mimoPLS.perm <- tepPLSCA(SNPS[perm.samples,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graph=F)#
	perm.eigs[i,] <- mimoPLS.perm$TExPosition.Data$eigs#
}#
original.eigs.matrix <- matrix(mimoPLS$TExPosition.Data$eigs,perm.iters,length(mimoPLS$TExPosition.Data$eigs),byrow=T)#
#
	### test each component:#
component.p.values <- pmax(1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters), 1/perm.iters)#
	### omnibus test#
omnibus.p.value <- max(1-(sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))  / perm.iters), 1/perm.iters)
####This script shows how to perform each analysis as outlined in the paper.#
#
rm(list=ls())#
gc()#
#
source('LibsFuncs.R')#
#
load('../Data/SNPS.rda') 	##SNPS data#
load('../Data/TRAITS.rda')	##TRAITS data#
load('../Data/CONTINUOUS.rda')	##CONTINUOUS data#
load('../Data/DES.rda')		##Participant design matrix -- indicates e.g., group relationship#
## mixed modality PLS can be performed in two ways:#
#
	## with the Escofier recoding transform:#
mimoPLS <- tepPLSCA(SNPS,escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graphs=F)#
## Examples of inference tests below. Only permutation and bootstrap provided.#
#
	### Permutation: 100 iterations only. Increase as required.#
perm.iters <- 100#
perm.eigs <- matrix(NA,perm.iters,length(mimoPLS$TExPosition.Data$eigs))#
for(i in 1:perm.iters){#
	perm.sample <- sample(nrow(SNPS),nrow(SNPS),F)#
	mimoPLS.perm <- tepPLSCA(SNPS[perm.sample,],escofier.transform(CONTINUOUS),T,F,DESIGN=DES,make_design_nominal=F,graph=F)#
	perm.eigs[i,] <- mimoPLS.perm$TExPosition.Data$eigs#
}#
original.eigs.matrix <- matrix(mimoPLS$TExPosition.Data$eigs,perm.iters,length(mimoPLS$TExPosition.Data$eigs),byrow=T)#
#
	### test each component:#
component.p.values <- pmax(1-(colSums(original.eigs.matrix > perm.eigs) / perm.iters), 1/perm.iters)#
	### omnibus test#
omnibus.p.value <- max(1-(sum(sum(mimoPLS$TExPosition.Data$eigs) > rowSums(perm.eigs))  / perm.iters), 1/perm.iters)
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- matrix(NA,nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs))#
fj.boot <- matrix(NA,nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs))
boot.sample <- boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS
boot.sample
length(boot.sample)
sum(boot.R)
caSupplementalElementsPreProcessing
boot.sample <- 1:nrow(SNPS) #boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS
caSupplementalElementsPreProcessing
rowNorms(boot.R,type="ca")
rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)
(rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)) / mimoPLS$TExPosition.Data$fi
(rowNorms(t(boot.R),type="ca") %*% mimoPLS$TExPosition.Data$fi %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)) / mimoPLS$TExPosition.Data$fj
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- matrix(NA,nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs))#
fj.boot <- matrix(NA,nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs))#
for(i in 1:boot.iters){#
	boot.sample <- 1:nrow(SNPS) #boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS#
	fi.boot[,,i] <- rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)#
	fj.boot[,,i] <- rowNorms(t(boot.R),type="ca") %*% mimoPLS$TExPosition.Data$fi %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)#
}
i
rowNorms(boot.R,type="ca")
rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)
mimoPLS$TExPosition.Data$fi
rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)
fi.boot[,,i] <- rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)
dim(fi.boot)
dim(rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))
fi.boot[,,i] <- (rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
fj.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs),boot.iters))
fi.boot[,,i] <- (rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
fj.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
for(i in 1:boot.iters){#
	boot.sample <- 1:nrow(SNPS) #boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS#
	fi.boot[,,i] <- (rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))#
	fj.boot[,,i] <- rowNorms(t(boot.R),type="ca") %*% mimoPLS$TExPosition.Data$fi %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)#
}
fi.boot
fi.bsrs <- boot.ratio.test(fi.boot)
fi.bsrs$sig.boot.ratios[,1:2]
fi.boot
fi.boot[,,1]
fi.boot[,,1]  / mimoPLS$TExPosition.Data$fi
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
fj.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
for(i in 1:boot.iters){#
	boot.sample <- boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS#
	fi.boot[,,i] <- (rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))#
	fj.boot[,,i] <- rowNorms(t(boot.R),type="ca") %*% mimoPLS$TExPosition.Data$fi %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)#
}
fi.bsrs <- boot.ratio.test(fi.boot)
fi.bsrs$sig.boot.ratios[,1:2]
fi.boot
which(is.na(fi.boot))
which(is.nan(fi.boot))
nom.SNPS <- makeNominalData(SNPS)#
boot.iters <- 100#
fi.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fi),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
fj.boot <- array(NA,dim=c(nrow(mimoPLS$TExPosition.Data$fj),length(mimoPLS$TExPosition.Data$eigs),boot.iters))#
for(i in 1:boot.iters){#
	boot.sample <- boot.samples(SNPS,DES,T)#
	boot.nom.SNPS <- nom.SNPS[boot.sample,]#
	boot.ESCOFIER.CONTINUOUS <- escofier.transform(CONTINUOUS[boot.sample,])#
	boot.R <- t(boot.nom.SNPS) %*% boot.ESCOFIER.CONTINUOUS#
	fi.boot[,,i] <- (rowNorms(boot.R,type="ca") %*% mimoPLS$TExPosition.Data$fj %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv))#
	fi.boot[is.na(fi.boot)] <- 0#
	fj.boot[,,i] <- rowNorms(t(boot.R),type="ca") %*% mimoPLS$TExPosition.Data$fi %*% diag(1/mimoPLS$TExPosition.Data$pdq$Dv)#
	fj.boot[is.na(fj.boot)] <- 0	#
}
fi.bsrs <- boot.ratio.test(fi.boot)
fi.bsrs$sig.boot.ratios[,1:2]
fj.boot[,,1]
colnames(escofier.transform(CONTINUOUS))
fj.boot[1:30,,]
abs(fj.boot[1:30,,]) - fj.boot[31:60,,]
(abs(fj.boot[1:30,,]) - fj.boot[31:60,,])
boot.ratio.test((abs(fj.boot[1:30,,]) - fj.boot[31:60,,]))
fj.bsrs <- boot.ratio.test(fj.boot)
fj.bsrs$sig.boot.ratios[,1:2]
fj.bsrs$boot.ratios[,1:2]
boot.ratio.test((fj.boot[31:60,,] - fj.boot[1:30,,]))
fj.bsrs <- boot.ratio.test(fj.boot)#
fj.bsrs_proper <- boot.ratio.test((fj.boot[31:60,,] - fj.boot[1:30,,]))
fj.bsrs$boot.ratios[31:60,1:2]
fj.bsrs_proper$boot.ratios[,1:2]
fj.bsrs$boot.ratios[31:60,1:2] / fj.bsrs_proper$boot.ratios[,1:2]
fj.bsrs$boot.ratios[31:60,1:2] - fj.bsrs_proper$boot.ratios[,1:2]
fj.bsrs_proper$boot.ratios[,1:2]
fj.bsrs$boot.ratios[31:60,1:2]
fj.bsrs$boot.ratios[1:30,1:2]
fj.bsrs$boot.ratios[31:60,1:2]
fj.bsrs$boot.ratios[1:5,1:2]
fj.bsrs$boot.ratios[31:35,1:2]
fj.bsrs_proper$boot.ratios[1:5,1:2]
fj.bsrs_proper$boot.ratios[1:5,1:2]/2
fj.bsrs$sig.boot.ratios[1:30,1:2]
fj.bsrs$sig.boot.ratios[1:30,1:2] - fj.bsrs$sig.boot.ratios[31:60,1:2]
fj.bsrs$sig.boot.ratios[1:30,1:2] - fj.bsrs_proper$sig.boot.ratios[,1:2]
fj.bsrs$sig.boot.ratios[31:60,1:2] - fj.bsrs_proper$sig.boot.ratios[,1:2]
fj.bsrs_proper$sig.boot.ratios[,1:2]
fj.bsrs$sig.boot.ratios[31:60,1:2] - fj.bsrs_proper$sig.boot.ratios[,1:2]
fj.bsrs$boot.ratios[c(8,16,26),1:2]
fj.bsrs_proper$boot.ratios[c(8,16,26),1:2]
abs(fj.bsrs$boot.ratios[,]) > 1.96
abs(fj.bsrs$boot.ratios[,]) > 1.96 & abs(fj.bsrs$boot.ratios[,]) < 2.1
sum(abs(fj.bsrs$boot.ratios[,]) > 1.96 & abs(fj.bsrs$boot.ratios[,]) < 2.1)
fj.bsrs$boot.ratios[29,4]
fj.bsrs$boot.ratios[59,4]
rownames(fj.boot) <- rownames(mimoPLS$TExPosition.Data$fj)
rownames(fi.boot) <- rownames(mimoPLS$TExPosition.Data$fi)
fj.bsrs$boot.ratios[c(29,59),4]
fj.bsrs$boot.ratios[c(29,59),1:4]
fi.bsrs <- boot.ratio.test(fi.boot)#
fj.bsrs <- boot.ratio.test(fj.boot)	## stability of each point; but because of dual coding this is incorrect.#
fj.bsrs_proper <- boot.ratio.test((fj.boot[31:60,,] - fj.boot[1:30,,])) ## stability of the *difference*
fj.bsrs$boot.ratios[c(29,59),1:4]
